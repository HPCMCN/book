# 1. 匹配规则

## 1.1 统配符

| 符号 | 说明                                                    |
| ---- | ------------------------------------------------------- |
| `.`  | 匹配任意(除了`\n`), 不过滤`\n`可以使用`flags=re.DOTALL` |
| `\d` | 匹配`0-9`                                               |
| `\D` | 取反`\d`                                                |
| `\w` | 匹配`a-z` + `A-Z` + `0-9` + `_` + `中文`                |
| `\W` | 取反`\w`                                                |
| `\s` | 匹配`空格`, `\t`, `\n`, `\r`, `\f`, `\v`                |
| `\S` | 取反`\s`                                                |

## 1.2 数量匹配

| 符号    | 说明                                                         |
| ------- | ------------------------------------------------------------ |
| `*`     | 重复匹配0到多个, 默认贪婪模式                                |
| `+`     | 重复匹配1到多个, 默认贪婪模式                                |
| `{m}`   | 重复匹配m个                                                  |
| `{m,n}` | 重复匹配m到n个, 默认贪婪模式                                 |
| `?`     | 1. 禁用贪婪模式<br>2. 对于前面字符存在还是不存在均匹配成功   |
| `|`     | `A|B`匹配满足A或者满足B的, A成功匹配则不会再次匹配B          |
| `[]`    | 匹配总括中的每一个字符. <br>1. 非开头或结尾的`-`表示数字/字母区间(可以转义此符号), 如`[0-9A-Fa-f]`; <br>2. 可以使用通配符`\w, \s`等符号多种匹配; <br>3. 开头位置使用`^`符号可以取反;<br>4. Python预保留符号`--`, `&&`, `||`, 使用这些符号最好转义, 否则会有提示 |
| `\`     | 转义符号, 正常情况下需要在表达式前加`r`进行转义, 否则`\w`就需要`\\w`来转义了 |

## 1.3 边界匹配

| 符号 | 含义                                                         |
| ---- | ------------------------------------------------------------ |
| `\b` | 匹配字符串边界(起始边界, 空格边界), <br>`"abc cd 你好啊"`用`\b\w{3}\b`可以比配到`['abc', '你好啊']` |
| `B`  | 取反`\b`                                                     |
| `\A` | 起始边界匹配                                                 |
| `\Z` | 末尾边界匹配                                                 |
| `^`  | 起始匹配                                                     |
| `$`  | 终止匹配                                                     |

## 1.4 分组匹配

| 方法                                                | 含义                                                         |
| --------------------------------------------------- | ------------------------------------------------------------ |
| `(...)`                                             | 匹配括号内中的正则表达式, 可以`\number`来重复使用这个表达式  |
| `\number`                                           | 按照次序复用正则分组                                         |
| `(?aiLmsux-imsx)`<br>或者:<br>`(?aiLmsux-imsx:...)` | `-`前边`a`, `i`, `L`, `m`, `s`, `u`, `x`分别对应flags中的re.A, re.I, re.L, re.M, re.S, re.U, reX, 可以组合, 后边表示移除的项目, 此配置为当前正则的全局设置, 可以只设置或者只移除的 |
| `(?P<name>...)`                                     | 给当前分组取名称`name`, 方便后面正则调用. 1. 调用可以使用序号`5`或者`2`, 2. 结果获取, `group("name")`或者`end("name")`; 3. sub替代传递, `\g<name>`或者`\g<1>`或者`\1` |
| `(?P=name)`                                         | 对命名分组的调用                                             |
| `(?:...)`                                           | 此分组不会在结果中输出                                       |
| `(?#...)`                                           | 正则中的注释信息                                             |
| `(?=...)`                                           | 后边界匹配...中的信息, `Isaac(?=Asimov)`匹配`IsaacAsimov`结果`Isaac` |
| `(?!...)`                                           | `(?=...)`的对立面, 后边界取反                                |
| `(?<=..)`                                           | 前边界匹配...中的信息, 注意此匹配是从后往前匹配的. 允许使用` |
| `(?<!...)`                                          | `(?<=..)`的对立面, 前边界取反                                |
| `(?(id/name)yes-pattern|no-pattern)`                | 如果id/name存在,则执行yes-pattren, 否则执行no-pattern.       |

## 1.5 匹配模式

| 序号 | 方法       | 含义                                                         |
| ---- | ---------- | ------------------------------------------------------------ |
| 1    | `re.A`     | 让统配符号只支持ASCII, 而不是全部str. 可以使用`re.ASCII`     |
| 2    | `re.I`     | 忽略大小写, 作用于str. 可以使用`re.IGNORECASE`               |
| 3    | `re.L`     | 忽略大小写, 作用于bytes. 可以使用`re.LOCALE`                 |
| 4    | `re.M`     | 多行匹配. 可以使用`re.MULTILINE`                             |
| 5    | `re.S`     | 让通配符`.`可以统配`\n`, 即`.`可以统配所有内容. 可以使用`re.DOTALL` |
| 6    | `re.X`     | 允许正则表达式中添加注释. 可以使用`re.VERBOSE`               |
| 7    | `re.DEBUG` | 开启正则编译时的debug信息                                    |

# 2. 特殊规则

## 2.1 贪婪模式

贪婪模式: 在满足匹配条件下, 匹配尽可能多的数据.

示例:

```Python
输入字符        匹配规则         匹配字符
"aaaaabb"  ---> "a+"   --->  "aaaaa"
```

禁用贪婪模式:

```Python
输入字符        匹配规则         匹配字符
"aaaaabb"  ---> "a+?"   --->  "a"
```



## 2.2 禁用分组

一般情况下: 

* `()`在正则模式中, 是作为分组的存在
* 如果想纯粹的利用`()`的功能, 且不想使用分组, 可以使用`(?:xxx)`来禁用分组功能

示例:

```python
import re

test_str = "caabd"

print(re.findall("c(a.b|a.c)d", test_str))   # ['caabd']
print(re.findall("c(?:a.b|a.c)d", test_str)) # ['aab']
```



## 2.3 过滤指定字符

* 方法一

  使用`[]`实现

  语法说明

  ```Python
  # [xx]表示匹配中括号中的任意内容
  # [^xx]表示不匹配中括号中的任意内容
  ```

  

  示例

  ```Python
  test_str = "aabbcc"
  
  print(re.findall(r"bbcc[^e]{2}", test_str))
  ```

  输出

  ```bash
  ['bbccdd']
  ```

  

* 方法二

  使用分组边界限制实现, 可以使用分组过滤

  语法说明

  ```Python
  # (?!ab)  # 默认功能为前视取反, 表示不能以ab结尾, ab不占用正则内容
  # (?!ab).{2}  # 可以利用这个特性, 来屏蔽ab匹配, 但是需要占用ab的正则规则, 可以用.来统配两位来补充. 此方法需要注意的主要是ab需要增加匹配的长度
  ```

  

  示例

  ```python
  test_str = "<a>a标签</a><a>b标签</a>"
  
  print(re.findall(r"(<(?P<lb1>\w)>(?!(?P=lb1))\w{3,}</(?P=lb1)>)", test_str, flags=re.S))
  ```

  输出

  ```bash
  [('<a>b标签</a>', 'a')]
  ```

  

  

