# 1. 配置文件

自动为各个node的keepalived/haproxy节点生成证书, 自动向apiserver申请证书, 颁发证书, 管理证书

单个master01节点执行, 然后发送到其他节点

* 创建环境

  ```shell
  # 指定集群
  # 注意server需要改为VIP+apiserver port
  kubectl config set-cluster kubernetes --certificate-authority=/etc/kubernetes/pki/ca.pem --embed-certs=true    --server=https://10.111.0.111:16443 --kubeconfig=/etc/kubernetes/bootstrap-kubelet.kubeconfig
  
  # 设置token
  # 注意token可以修改, 但是位数不能变
  kubectl config set-credentials tls-bootstrap-token-user     \
     --token=c8ad9c.2e4d610cf3e7426e \
     --kubeconfig=/etc/kubernetes/bootstrap-kubelet.kubeconfig
  
  # 设置环境
  kubectl config set-context tls-bootstrap-token-user@kubernetes     \
     --cluster=kubernetes     \
     --user=tls-bootstrap-token-user    \
     --kubeconfig=/etc/kubernetes/bootstrap-kubelet.kubeconfig
  
  # 开始执行操作
  kubectl config use-context tls-bootstrap-token-user@kubernetes     --kubeconfig=/etc/kubernetes/bootstrap-kubelet.kubeconfig
  ```

* 修改配置

  ```shell
  vim bootstrap.secret.yaml 
  
  apiVersion: v1
  kind: Secret
  metadata:
    name: bootstrap-token-c8ad9c  # 注意这里token修改需要变更
    namespace: kube-system
  type: bootstrap.kubernetes.io/token
  stringData:
    description: "The default bootstrap token generated by 'kubelet '."
    token-id: c8ad9c  # 注意这里token修改需要变更
    token-secret: 2e4d610cf3e7426e  # 注意这里token修改需要变更
    usage-bootstrap-authentication: "true"
    usage-bootstrap-signing: "true"
    auth-extra-groups:  system:bootstrappers:default-node-token,system:bootstrappers:worker,system:bootstrappers:ingress
   
  ---
  apiVersion: rbac.authorization.k8s.io/v1
  kind: ClusterRoleBinding
  metadata:
    name: kubelet-bootstrap
  roleRef:
    apiGroup: rbac.authorization.k8s.io
    kind: ClusterRole
    name: system:node-bootstrapper
  subjects:
  - apiGroup: rbac.authorization.k8s.io
    kind: Group
    name: system:bootstrappers:default-node-token
  ---
  apiVersion: rbac.authorization.k8s.io/v1
  kind: ClusterRoleBinding
  metadata:
    name: node-autoapprove-bootstrap
  roleRef:
    apiGroup: rbac.authorization.k8s.io
    kind: ClusterRole
    name: system:certificates.k8s.io:certificatesigningrequests:nodeclient
  subjects:
  - apiGroup: rbac.authorization.k8s.io
    kind: Group
    name: system:bootstrappers:default-node-token
  ---
  apiVersion: rbac.authorization.k8s.io/v1
  kind: ClusterRoleBinding
  metadata:
    name: node-autoapprove-certificate-rotation
  roleRef:
    apiGroup: rbac.authorization.k8s.io
    kind: ClusterRole
    name: system:certificates.k8s.io:certificatesigningrequests:selfnodeclient
  subjects:
  - apiGroup: rbac.authorization.k8s.io
    kind: Group
    name: system:nodes
  ---
  apiVersion: rbac.authorization.k8s.io/v1
  kind: ClusterRole
  metadata:
    annotations:
      rbac.authorization.kubernetes.io/autoupdate: "true"
    labels:
      kubernetes.io/bootstrapping: rbac-defaults
    name: system:kube-apiserver-to-kubelet
  rules:
    - apiGroups:
        - ""
      resources:
        - nodes/proxy
        - nodes/stats
        - nodes/log
        - nodes/spec
        - nodes/metrics
      verbs:
        - "*"
  ---
  apiVersion: rbac.authorization.k8s.io/v1
  kind: ClusterRoleBinding
  metadata:
    name: system:kube-apiserver
    namespace: ""
  roleRef:
    apiGroup: rbac.authorization.k8s.io
    kind: ClusterRole
    name: system:kube-apiserver-to-kubelet
  subjects:
    - apiGroup: rbac.authorization.k8s.io
      kind: User
      name: kube-apiserver
  
  ```

# 2. 安装TLS

## 2.1 环境配置

本部分需要全部节点执行

* kubectl环境变量

  ```shell
  mkdir -p /root/.kube ; cp /etc/kubernetes/admin.kubeconfig /root/.kube/config
  ```

* 其他与生成文件夹

  ```shell
  mkdir -p /var/lib/kubelet /var/log/kubernetes /etc/systemd/system/kubelet.service.d /etc/kubernetes/manifests/
  ```

## 2.2 构建服务

* 开始创建

  master01节点创建
  
  ```shell
  kubectl create -f bootstrap.secret.yaml 
  ```
  
* 将生成好的配置发送到其他节点

  ```shell
  cd /etc/kubernetes/
  
  for NODE in master02 master03 node01 node02; do
       ssh $NODE mkdir -p /etc/kubernetes/pki
       for FILE in pki/ca.pem pki/ca-key.pem pki/front-proxy-ca.pem bootstrap-kubelet.kubeconfig admin.kubeconfig; do
         scp -r /etc/kubernetes/$FILE $NODE:/etc/kubernetes/${FILE}
       done
  done
  ```

* 全部测试

  ```shell
  kubectl get cs
  
  tail -f /var/log/messages
  ```


# 3. 介绍

kubelet启动过程

* kubelet 启动, 并检查`/etc/kubernetes/admin.kubeconfig`, 如果没有这个文件, 会

  以下为 TLS初始化流程

  * 读取`/etc/kubernetes/bootstrap.kubeconfig`, 检索apiserver的url和token信息, 

  * kubelet使用此token连接apiserver

  * apiserver根据token信息, 创建出对应的权限

    * token-id为token值

    * 隶属于system:bootstrappers组

      ```shell
      kubectl get secret -n kube-system bootstrap-token-c8ad9c -oyaml | grep "auth-extra-groups" | awk  'BEGIN{FS=": "} {print $2}' | base64 --decode
      ```

    * 构建可申请的CSR权限, 用于

      * clusterrole整个集群的权限
      * clusterrolebinding集群绑定权限, 用于某个clusterrole绑定到某个用户, 集群, serviceaccount

      ```shell
      kubectl get clusterrole
      kubectl get clusterrole system:node-bootstrapper -oyaml 
      # 归属于: certificates.k8s.io 组
      kubectl get clusterrolebinding kubelet-bootstrap -oyaml
      # 绑定: system:bootstrappers:default-node-token 组, 和system:bootstrappers里面配置的组是一致的
      ```

  * kubelet为自己申请注册了一个CSR, 名称`kubernetes.io/kube-apiserver-client-kubelet`, CSR的证书申请方式:

    * k8s管理员手动颁发

    * 如果配置权限, kube-contraoller-manager中CSRApprovingController, 会校验CSR中的username和group是否具有创建CSR的权限, 并且是否归属`kubernetes.io/kube-apiserver-client-kubelet`, 如果通过则自动同意和颁发证书

      ```shell
      # 查看绑定ClusterRole
      kubectl get clusterrolebinding node-autoapprove-bootstrap -oyaml
      # 查看对应的权限
      kubectl get ClusterRole system:certificates.k8s.io:certificatesigningrequests:nodeclient -oyaml
      ```

  * kube-contraoller-manager更新证书至CSR的status字段
  * kubelet从apiserver中获取证书
  * kubelet根据key和证书, 创建`/etc/kubernetes/admin.kubeconfig`文件
  * [可选] 如果配置了自动续期, 会根据`/etc/kubernetes/admin.kubeconfig`重新进行续签新的证书

* 检索此文件中的ApiServer的url和证书信息

  ```shell
  # 查看当前证书有效期
  grep "certificate-authority-data" /etc/kubernetes/admin.kubeconfig | awk  'BEGIN{FS=": "} {print $2}' | base64 --decode | openssl x509 -noout -dates
  ```

* 然后使用这个证书和apiserver进行交互

